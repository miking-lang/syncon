// === ../base ===

token Ident = "[[:lower:]][[:alnum:]_']*"
token UIdent = "[[:upper:]][[:alnum:]_']*"
token Integer = "[0-9]+"

type Exp
grouping "(" Exp ")"

type Stm
grouping "{" Stm "}"

type Pat
grouping "(" Pat ")"

type Type
grouping "(" Type ")"

type Decl


syncon decls: Top = decls:Decl+
syncon main: Decl =
  "main" "{" body:Stm "}"

infix right seqComp: Stm = ";"
syncon letStm: Stm = "let" p:Pat (":" t:Type)? "=" e:Exp
syncon return: Stm = "return" e:Exp?

syncon intLit: Exp = i:Integer
syncon var: Exp = i:Ident

syncon wildNamePat: Pat = i:Ident
syncon wildNoNamePat: Pat = "_"
syncon intPat: Pat = i:Integer

syncon namedType: Type = n:UIdent



// === ocaml/fun ===

prefix ocamlFun: Exp =
  "fun" p1:OcamlParameter*
  ( p2: OcamlParameter ":" ty:Type
  | p3:OcamlParameter) "->"

type OcamlParameter
syncon ocamlPatParam: OcamlParameter = p:Pat



// === ocaml/fun_labelled ===

syncon ocamlSimpLabelParam: OcamlParameter =
  "~" l:Ident
syncon ocamlTyLabelParam: OcamlParameter =
  "~" "(" l:Ident (":" ty:Type)? ")"
syncon ocamlLabelPatParam: OcamlParameter =
  "~" l:Ident ":" p:Pat
syncon ocamlSimpOptParam: OcamlParameter =
  "?" l:Ident
syncon ocamlTyOptParam: OcamlParameter =
  "?" "(" l:Ident (":" ty:Type)? ("=" def:Exp)? ")"
syncon ocamlOptPatParam: OcamlParameter =
  "?" l:Ident ":" p:Pat
syncon ocamlOptPatTyParam: OcamlParameter =
  "?" l:Ident ":" "(" p:Pat
  ( ":" ty:Type ("=" def:Exp)?
  | "=" def2:Exp)
  ")"

