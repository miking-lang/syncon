----------------------- REVIEW 1 ---------------------
SUBMISSION: 79
TITLE: Resolvable Ambiguity
AUTHORS: Viktor Palmkvist, Elias Castegren, Philipp Haller and David Broman

----------- Overall evaluation -----------
SCORE: 1 (weak accept)
----- TEXT:
The paper identifies the notion of "resolvable ambiguity" (RA) in
  context-free grammars. A word in a language is resolvable ambiguous
  if for any of its parsing trees there is another word, for which
  this tree is unique. That is, the initial "ambiguous" word can be
  disambiguated in a certain way, e.g., by putting the necessary
  parentheses or other precedence operators. The paper provides formal
  definitions of RA and presents two algorithms determining RA: (a)
  dynamically (for a given word) and (b) statically (for a given
  restricted language). The paper presents a DSL for defining grammars
  amenable to the above mentioned analyses and evaluates it on two
  case studies.

  Overall, as a paper about parsing, this work presents a well-scoped
  problem, backed with a sufficient amount of theory and some
  evaluation. As an outsider to this area, I'm mostly concerned about
  the practical aspects of using the idea of RA for developing
  programming languages. That is, the case studies, besides mentioning
  some large language developments (a subset of OCaml) didn't give me
  a good sense of what is it like to define an ambiguous grammar in a
  general work flow of building a compiler. In this regard, I'm also
  not entirely convinced that having a fully unambiguous grammar from
  the beginning is a Bad Thing. It would be nice if the paper
  elaborated more on it, showing making a convincing case why the
  flexibility afforded by RA is worthy of practical consideration.

  The writing of the paper, while mostly coherent, is a bit uneven at
  some places. For instance, it mentions "parse tree being visibly
  pushdown" on page two without any definition of what visibly
  pushdown automaton is (I had to look it up).

  Small nits:

  * Definition 4: $w'$ should be just $w$.
----------- Reviewer's confidence -----------
SCORE: 1 ((no familiarity))
----------- Questions for author response -----------
* Could you please explain the intended mode of interaction with
  your tool for dynamic and static analysis of ambiguity, when
  developing a new language? Specifically, assuming a dynamic analysis
  determines a certain program to be resolvably ambiguous, what is the
  programmer expected to do next? What about static analysis?


----------------------- REVIEW 2 ---------------------
SUBMISSION: 79
TITLE: Resolvable Ambiguity
AUTHORS: Viktor Palmkvist, Elias Castegren, Philipp Haller and David Broman

----------- Overall evaluation -----------
SCORE: -1 (weak reject)
----- TEXT:
The paper describes disambiguation mechanisms for context-free languages.
Although that parsing is considered more or less a finished topic it is
good that there are still a number of researchers that work on this topici
and produce interesting results. The creation of domain specific languages
and the composition of grammars poses interesting new research challenges,
certainly in the area of ambiguity resolution. The description of legacy
languages also imposes interesting challenges to ambiguity resolution.
The paper contributes to this interesting research area by introducting
two different disambiguation mechanisms for context-free languages.

Although that the paper starts strong, I got less excited during
reading the entire paper. Overall the paper is well structured but
not always very readable.

Section 1 gives an overall introduction to parsing, grammars and ambiguities.

Section 2 introduces a number of motivating examples of grammars and
possible ambiguities, related to binary operators, "dangling-else" problem,
and language composition.

Section 3 introduces the some notation. I wonder why a separate section is
needed for this.

Section 4 introduces the concept of ambiguity resolution. A number of
definitions are presented. I had some trouble in understand definition 4,
what is the relation between w and w', is w' a modified version (with
inserted brackets) of w?
In definition 5 you use \rho_P with w as argument as well as t, is this
what you mean?
It may be possible that after disambiguation all obtained trees are
removed, how do your definitions take care of this?

Section 5 introduces the parse-time disambiguation. I miss in figure 3
the production of the brackets, in figure 4(d) the bracket production
is explicitly introduced. In figure 3 you use the + operator in the right
hand side of the production rule for E (with label l), I assume this is
reads as alternative.
I am totally confused by the last paragraph on page 10 where you show
2 alternative representations of the sentence (1+2)*3 of which you claim
that these representations are ambiguous, why?
At the bottom of page 11 you introduce a new for sequential composition
which leads to ambiguities for the grammar G_D of page 10, or not? I fail
to see the point that you try to make here. The explanation at the top
of page 12 does not help me in understanding your point.
The example in the first paragraph of 5.1 contains a typo, the second "2"
should be a "3".

Section 6 introduces dynamic ambiguity resolution. One question that remains
after reading this section is whether your approach is applicable to
ambiguities that cannot be resolved by introducing paired brackets?
Please explain the automaton at the top of page 13 better, are you able
to recognize [(((a))(b))], I do not think so? Please add a number of
small examples to this section to clarify your approach.

Section 7 introduced the static ambiguity resolution. This section is
unfortunately very hard to understand. Specially in section 7.1 the
presentation is "cluttered", the example does not contribute to understanding
the algorithm. The step from the 3 DFAs on page 16 to the automata presented
on pages 17 and 18 is too big. The added explanation does not clarify the
resulting automata and how to use them. Given this observation the rest
of this section is very hard to understand.

Section 8 introduces 2 case studies, together with the introduction of the
grammar formalism. The used notion in the grammar formalism is a bit
unusual: 'infix add: Exp = "+"', I assume that in a traditional way
this would have been written as 'E = E "+" E'? The "forbid" functionality
is introduced, but none of the examples show explicitly how it is used.
The next section introduces compositionality of grammars and corresponding
ambiguity problems. You have a strong claim at the end of section 8.2, but
I miss the actual motivation for this claim. Section 8.3 has in my opinion
not much added value in its current form. It does not make a strong case
for the approach presented in this paper.

Section 9 presents related work, it is fairly complete, although that
some interesting papers have been published related to disambiguation
and (S)GLR parsing. In a number of these papers the "longest match"
problem have been addressed, which as described int Section 10 (Conclusions)
is future work.
----------- Reviewer's confidence -----------
SCORE: 3 ((expert))
----------- Questions for author response -----------
I do not have specific questions.


----------------------- REVIEW 3 ---------------------
SUBMISSION: 79
TITLE: Resolvable Ambiguity
AUTHORS: Viktor Palmkvist, Elias Castegren, Philipp Haller and David Broman

----------- Overall evaluation -----------
SCORE: -1 (weak reject)
----- TEXT:
The authors argue (following others) that the syntax of a language
does not necessarily have to be unambiguous. They define the concept
of "resolvable ambiguity": ambiguity that can be resolved by
changing the string that is parsed. They also present an algorithm
(for a certain class of languages) that, for a given word, produces
unambiguous minimal words for each of the possible parse trees for
that word, or states that there is no such unambiguous word. Such an
algorithm can be used to aid programmers who write ambiguous code.
Finally the authors present an algorithm, for a seemingly rather
restrictive class of languages, that decides whether every parse
tree is the result of parsing an unambiguous word.

I liked the main ideas of the text. However, lots of details, and
also some high-level explanation, were omitted. For instance, I had
a hard time understanding the first algorithm. For this reason I do
not vouch for the correctness of what is presented in the paper.
This problem could have been mitigated somewhat if the paper had
been accompanied by machine-checked proofs, but there is no
indication that such proofs exist.

My suggestion for the authors is to either write a longer paper, or
to remove the part about the second algorithm and instead expand the
explanation of the first one (and other parts). I did not see the
point of the second algorithm, because the class of languages that
it supports seemed rather restrictive to me. The authors discussed
how the first algorithm could be used (and I liked that discussion),
but there was no similar discussion of the second algorithm.

Another omission: There was no discussion of the time complexity of
the algorithms, or even some indication of whether the authors'
implementations run quickly in practice.

Overall: I liked the ideas, especially the definition of resolvable
ambiguity and the (concept of the) first algorithm. However, given
that I had a hard time understanding the first algorithm, I do not
think that the paper should be published in its current form.

Detailed comments for the authors:

ยง1: Please state right away that you have not solved the static
resolvability problem for languages where parentheses are used both
for grouping and for other things (like procedure/method
applications). Perhaps you could also indicate what kind of
languages you have solved the problem for.

Definition 4: w' should be w.

Definitions 9 and 10: Swap the two conjuncts of the "for all" part
so that ฮฃ is "in scope" when it is used.

Figure 2: Regular expressions typically include an expression for
the empty language. Why is this expression not included?

ยง5: Is there no formal definition of how the four grammars are
generated? How do these processes compare to similar processes
discussed by other authors?

ยง5: In what sense is words an inverse of parse?

ยง5: You did not state how you turn a language definition D into a
parser P. Does this involve making parse return the empty set for
words in ฮฃ^*-L(G'_D)?

ยง5.1: Have you proved that the canonical linear encoding is unique?
I would have liked to see more details, including a proof that this
encoding can be computed, efficiently and correctly.

ยง5.1: You claim that "Section 6 fully solves the dynamic problem",
but in ยง6 you introduce two restrictions.

ยง6: It seems as if you only intended to handle languages with
balanced parentheses. In that case you could have moved the first
restriction to ยง5, in which case it would no longer be a restriction
of the algorithm.

ยง6: What does "but with parentheses removed" mean? Please be more
precise.

ยง6: You write that the restrictions can be checked statically. I
believe you, but I think you should explain how. I'd also like to
see some discussion of the time complexity of these checks.

ยง6: Please explain what a VPDA is. I see that you included some
information in an appendix, but I guess that information would have
to be cut if the paper is accepted for publication.

Algorithm 1: The dynamic resolvability problem takes a word as
input, not a set of parse trees. Is the intention that the algorithm
should be run with parse(w) as its input?

Algorithm 1: Please give a high-level explanation of what the
algorithm does. What is the purpose of the two sets returned from
the algorithm? ("Resolvable"/"Unresolvable"?) What is the purpose of
the final assignment in the inner loop?

My reading: Input: All parse trees for a certain word. For each
parse tree t we try to see whether this tree is resolvably
ambiguous. We do this by finding the words which generate t, but not
any other parse tree in T. If there is no such word, then t is not
resolvably ambiguous. If there is such a word, then t might still
not be resolvably ambiguous, so we check whether t is the unique
parse tree for one of the words, w (a minimal one). If t is unique,
then t is resolvably ambiguous. Otherwise we repeat the process for
the parse trees for w? No, not quite, A is not reset to words(t).
I'm not sure what invariants are supposed to hold in the algorithm,
and I don't understand why it must terminate. Perhaps I could figure
this out if I spent more time on it, but I think the explanation in
the paper should be better.

Algorithm 1: Is shortest(A) always (efficiently) computable for a
VPDA A?

Algorithm 1: Please discuss the algorithm's time complexity.

Algorithm 1, discussion of termination: When you write "that T' is
finite", do you mean "T"? You write that "T' is finite if no words
are infinitely ambiguous", but that sounds like a statement about
"parse(w)", not a statement about an almost unrestricted set.

Algorithm 1, discussion of termination, "T' is finite if no words
are infinitely ambiguous": With respect to what grammar or parser?

Algorithm 1, discussion of termination: What if there are no parse
trees "containing a production from N"?

Algorithm 1, discussion of termination: I did not understand exactly
how requirement 2, stated for "G_D without parentheses", ensures
termination. Please expand the explanation.

ยง7, "a pair of trees": /Distinct/ trees? The statement
ยฌโtโ,tโโL(T_D). words(tโ) โ words(tโ) is false whenever L(T_D) is
non-empty.

ยง7: I do not understand the table. Are the two entries in the
left-most column supposed to be identical?

ยง7: I did not understand the example with the list [1;2], perhaps
because I am not familiar with the syntax of OCaml. Does OCaml use ;
both to separate list elements and statements?

Proof of Theorem 2, "Given a tree t": A parse tree for the language
with marks? Please explain exactly how you patch the proof of
Theorem 1 to arrive at a proof of Theorem 2, I think the current
text is too vague.

ยง7.2: Is ambiguity decidable for VPDAs? What does "trimming" mean?

ยง7.2: When you write โ, do you mean "is a /proper/ subset of"?
Presumably not. In that case, why do you use two different symbols
meaning the same thing?

ยง7.2, "computing the closure": What do you mean by "computing"? Is
this relation finite?

ยง7.2, "Formalization": Why do you repeat the definitions of the
relation and the VPDAs?

ยง8.3, limitations: I think that the expression involving let would
be seen as unambiguous if the approach described by Aasa in
"Precedences in specifications and implementations of programming
languages" (TCS, 1995) was used.

ยง9, "though somewhat comparable to the subclass our static analysis
supports". In what sense? One can have LALR(1) parsers for at least
some languages where parentheses are used for both grouping and
other things.
----------- Reviewer's confidence -----------
SCORE: 3 ((expert))


----------------------- REVIEW 4 ---------------------
SUBMISSION: 79
TITLE: Resolvable Ambiguity
AUTHORS: Viktor Palmkvist, Elias Castegren, Philipp Haller and David Broman

----------- Overall evaluation -----------
SCORE: 2 (strong accept)
----- TEXT:
Summary
-------
The paper proposes to depart from the traditional choice of designing programming languages with unambiguous grammars, which imposes precedence and associativity rules to the user. Instead, the proposal is to let the user directly choose the disambiguation where necessary. The paper formalizes the problem of deciding whether this is always possible for a language definition, in two variants: a dynamic variant considering a particular program, and a static variant considering all programs written in a language. Solutions are given for (less and more) restricted language classes. Finally, the paper demonstrate the practical usefulness of the dynamic solution on two case studies.

Evaluation
----------
In my opinion, the paper goes in a very interesting direction. The motivating examples chosen by the authors are very convincing and struck a chord with me. Indeed, something similar to the first example (Section 2.1) also happens in Python with comparison operators chaining (and it is often very confusing for beginners). The remark made about not clear error messages Section 2.2 is also very valid: anybody who has programmed in OCaml at some point has certainly encountered something similar and suffered because of it.

Unfortunately, I found the core of the paper (Section 6 and 7) rather hard to follow for a reader not familiar with pushdown automata. The illustration by example in Section 7.2 helps only a little. I think that more intuitive explanations (and, ideally, further examples) would go a long way in improving the presentation. Minor remarks on previous sections are below.

Finally, I liked the case studies and, in particular, how the proposed approach can be also applied in the traditional language design settings to find ambiguities in real-world language specifications.

Minor remarks:
- Page 7: Can it happen in practice that two distinct words have the same parse tree? How does it happen?
- In Definition 3 the expression '\exists t_1, t_2...' can be simply replaced by '|parse(w)| >= 2'
- Similarly, below Definition 3, the expression '\exists t...' can be replace by '|parse(w)| = 1'
- In Definition 4 there is a w' that should just be w (or, vice-versa, both should be w')
- It would help to give an example to clearly show the difference between 'unambiguous' and 'resolvably ambiguous' already on page 7 (the example on page 11 could be moved here)
----------- Reviewer's confidence -----------
SCORE: 1 ((no familiarity))
----------- Questions for author response -----------
Can you give a summary of Section 6 and 7 that is more intuitive for an outsider?


----------------------- REVIEW 5 ---------------------
SUBMISSION: 79
TITLE: Resolvable Ambiguity
AUTHORS: Viktor Palmkvist, Elias Castegren, Philipp Haller and David Broman

----------- Overall evaluation -----------
SCORE: -1 (weak reject)
----- TEXT:
## Summary

This paper tackles the problem of ambiguity on grammars. This is
particularly a problem when composing grammars, since the composition
of two unambiguous grammars may be ambiguious, but appears in other
settings, as with the introduction of new operators with unknown
precedence.

The paper defines two notions of how easy it is to fix ambiguities
given an ambiguious grammar. In particular, a program is "resolvably
ambiguious" -- their new term -- if it _can be_ disambiguated, perhaps
by adding parentheses for grouping. This allows us to ask if _every_
program allowed by a grammar is resolvably ambiguious (this is the
static variant of the problem) or if one particular program is
resolvably ambiguious (this is the dynamic variant).

Further, the show that for a particular EBNF-like grammar formalism,
these questions are decidable and they give algorithms for them. The
algorithms rely on translating grammar definitions to visibly pushdown
automata.

They implement the system as a small Haskell library, and show how
resolvability can improve error messages. They also implement an OCaml
parser and use it to detect ambiguities in the grammar given by the
OCaml reference.

## Evaluation

This paper contributes several things:
  - a problem definition -- when do grammars support resolution of
    ambiguity?
  - algorithms to decide this problem for a particular formalism
  - some uses of those algorithms for reporting errors to users and
    managing grammar ambiguity

These all aim at real contributions, but it's not clear how well they
really fit together, and how significant they are.

First, the central motivation of the paper is that ambigious grammars
are useful but need better tooling and that can be provided by solving
these problems. Why is "resolvable ambiguity" the key to making
ambiguity palatable? On the one had, grammar composition does not
ensure that grammars are not unresolvably ambigious (see the Orc
example). On the other hand, there are many other strategies for
disambiguating. The paper discusses OCaml's use of typing for a simple
case, but other systems such as Isabelle tolerate many ambiguities in
the grammar as long as typing only accepts one of them.

Second, if the motivation is to provide the very nice error messages
of page 22, is a sound and complete algorithm needed? Note that no
implementation of static resolvability analysis is presented.

Finally, the OCaml grammar discussion was underwhelming. Simply
writing down the grammar and using any full-CFG parser would produce
the same results -- resolvable ambiguity isn't used at all.

One additional question is whether the new grammar formalism (dubbed
"syncons") is intended as an important new contribution, or merely a
technical device for demonstrating the issues of ambiguity. If the
former, more discussion of why it's an improvement would be
welcome. If the latter, its differences from existing systems should
be reduced.

### Smaller issues

- page 21: the number of new features in this grammar compared to the
  formalisms earlier makes this hard to follow.

- It's possible to avoid the problems described in 8.2 in much simpler
  ways -- simply reject programs that combine operators from multiple
  grammars without parentheses, rather than assuming the precedence
  should be a total order. This is, for example, how the Fortress
  language worked.

- In the discussion of parsers that produce parse forests, some
  discussion of how they handle these cases would be nice.
----------- Reviewer's confidence -----------
SCORE: 1 ((no familiarity))


------------------------------------------------------


==============================================

Thank you for the insightful comments! They will help improve future
versions of this paper. We begin by answering the explicit "Questions
for author response", then address some other comments. The latter exceed
the space limit, and are thus intended for an interested reviewer, or
the one posing that particular question.

Reviewer 1:
For a programmer, the dynamic analysis provides explicit solutions
to a resolvable ambiguity error, i.e., the programmer is expected
to replace the ambiguous section with one of the suggested solutions.
The static analysis should never be run by the programmer.
For a language designer, resolvable ambiguity provides a smoother way
to explore syntax. You can postpone disambiguation decisions until a
later point of development, when you have actually written some programs
using the syntax (or decide to leave the ambiguity). Note that changing
a language to make a previously ambiguous program unambiguous (via
precedence and the like) is a backwards compatible change. The static
analysis ensures that no unresolvable ambiguity can appear (with the
caveat that the current static analysis is limited). The language designer
is thus expected to change the grammar such that the unresolvable
ambiguity is no longer possible.

Reviewer 4:
Section 6 takes an ambiguous word, creates an automaton for each parse tree
(that recognizes the (possibly ambiguous) words that can parse as that tree),
then combines these to create automata that recognize unambiguous words for each
tree.
Section 7 describes a relation between trees that corresponds to an unresolvable
ambiguity, then describes a way to check for this relation using VPDAs. The
equivalence only holds for a limited language subclass.

# Other Comments

## Reviewer 2:
### It may be possible that after disambiguation all obtained trees are
removed, how do your definitions take care of this?
  Assuming disambiguation by programmer: that would imply that the
  new word $w'$ has $\mathit{parse}(w') = \emptyset$, which means it
  is not part of the language, whereby it is not a valid disambiguation.
  Assuming disambiguation by language designer: this just removes the
  word from the language, which is again not a valid disambiguation.
### I am totally confused by the last paragraph on page 10 where you show 2 alternative representations of the sentence (1+2)*3 of which you claim
that these representations are ambiguous, why?
  The ambiguous word is the corresponding one in $L(G_D)$ (note the absence
  of a prime), i.e., "1+2*3".
### At the bottom of page 11 you introduce a new for sequential composition which leads to ambiguities for the grammar G_D of page 10, or not? I fail to see the point that you try to make here. The explanation at the top of page 12 does not help me in understanding your point.
  $G_D$ already was ambiguous, but $G'_D$ was not. Having an ambiguous $G'_D$
  does not guarantee an unresolvable ambiguity, but it does cause one in this
  case. The intended point is to show an example of an unresolvable
  ambiguity, after which we mention how one might solve this particular one
### [...] whether your approach is applicable to ambiguities that cannot be resolved by introducing paired brackets?
  It cannot, since the design in Section 5 only discards grouping parentheses.
  One could formulate a different formalism, still following the definitions
  in Section 4, that discards more information, which can then be used for
  disambiguation, which naturally poses more challenges for the analyses.
### Please explain the automaton at the top of page 13 better, are you able to recognize [(((a))(b))], I do not think so?
  This automaton does not recognize any word containing '[' or ']', but it
  does indeed recognize (((a))(b)).

## Reviewer 3:
Thank you especially for the detailed comments on the more technical parts
of the paper. To avoid being long-winded we will not address all of them
here, but they will most certainly be considered for future versions.
### My suggestion for the authors is [...] to remove the part about the second algorithm [...]
  The static analysis is present because it gives a desireable guarantee
  for a language designer: a user cannot encounter an unresolvable
  ambiguity (with the limitations as caveats). However, using the
  extra space to explore complexity and performance concerns is an
  interesting idea.
### I'm not sure what invariants are supposed to hold in the algorithm
  Roughly, the invariants are the following:
  - A recognizes a subset of words(t), such that words(t) \ L(A) contains
    only ambiguous words.
  - T' contains trees that are known to be ambiguous with t for some word
    in L(A).

## Reviewer 5:
### Why is "resolvable ambiguity" the key to making ambiguity palatable?
  The reasoning is largely this: if the language is ambiguous then a user
  can write an ambiguous program. If they do, we need to present it in
  an understandable way that is helpful for solving the ambiguity. The user
  never sees an AST otherwise, whereby we would like to present clarifying
  source code. This is possible exactly when the ambiguity is resolvable,
  by definition.
### Finally, the OCaml grammar discussion was underwhelming. Simply writing down the grammar and using any full-CFG parser would produce the same results -- resolvable ambiguity isn't used at all.
  This is correct, with the small caveat that the errors produced
  by our methods were quite helpful in finding the underspecified
  places in the grammar.
### One additional question is whether the new grammar formalism (dubbed "syncons") is intended as an important new contribution, or merely a technical device for demonstrating the issues of ambiguity.
  It is a tool built using the ideas presented here, intended for
  other developments in the research group, thus its syntax is
  designed for that.
### It's possible to avoid the problems described in 8.2 in much simpler ways -- simply reject programs that combine operators from multiple grammars without parentheses, rather than assuming the precedenced should be a total order. This is, for example, how the Fortress language worked.
  Our tool also rejects programs combining operators without defined
  relative precedence, except we use the dynamic analysis to provide
  example resolutions, and we support this also for cases caused by
  something other than precedence or associativity.
